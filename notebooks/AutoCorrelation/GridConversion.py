# grid_conversion.py
# This program calculates the physical distance conversion factor (Index Unit -> km)
# based on the grid structure of the first time step.
# Generated by Gemini based on user request.

import netCDF4 as nc
import numpy as np
import os
from math import radians, sin, cos, sqrt, atan2
import matplotlib.pyplot as plt

# 1. 设定参数和文件路径 (与主程序保持一致)

indir='/home/jqiu/Programing/Wind/'
indir_results='/home/jqiu/Programing/AutoCorrelation/'
fnames=['hrdps_y2025m10d01.nc', 'hrdps_y2025m10d02.nc', 'hrdps_y2025m10d03.nc'] 
# 只需要读取第一个文件进行网格分析
day_index=0
ds=nc.Dataset(indir+fnames[day_index])

lats=ds.variables['nav_lat'][:] # 读取所有纬度数据
lons=ds.variables['nav_lon'][:] # 读取所有经度数据
ds.close()

# 地球平均半径 (单位：公里)
R_EARTH = 6371.0 

# -----------------------------------------------------
# 2. 定义 Haversine 距离计算函数
# -----------------------------------------------------

def haversine(lat1, lon1, lat2, lon2):
    """
    使用 Haversine 公式计算地球表面两点间的距离 (单位: km)
    输入经纬度必须是十进制度数。
    """
    # 将十进制度数转换为弧度
    lat1_rad, lon1_rad = radians(lat1), radians(lon1)
    lat2_rad, lon2_rad = radians(lat2), radians(lon2)

    dlon = lon2_rad - lon1_rad
    dlat = lat2_rad - lat1_rad

    # Haversine 公式
    a = sin(dlat / 2)**2 + cos(lat1_rad) * cos(lat2_rad) * sin(dlon / 2)**2
    c = 2 * atan2(sqrt(a), sqrt(1 - a))

    distance = R_EARTH * c
    return distance

# -----------------------------------------------------
# 3. 计算每个索引步长的物理距离
# -----------------------------------------------------

print("开始计算网格索引到物理距离的换算因子...")

rows, cols = lats.shape
print(f"网格维度: {rows} (Y) x {cols} (X)")

# 只考虑网格内部的点，避免边界问题
test_rows = np.arange(1, rows - 1)
test_cols = np.arange(1, cols - 1)

# 存储每一步长的距离
x_step_distances = [] # 水平 (X) 方向的距离
y_step_distances = [] # 垂直 (Y) 方向的距离

# A. 计算水平 (X) 方向的步长距离
# 遍历一行中的所有点，计算相邻点间的距离
for i in test_rows:
    for j in test_cols:
        # 选取当前点 (i, j) 和它右边的点 (i, j+1)
        lat1, lon1 = lats[i, j], lons[i, j]
        lat2, lon2 = lats[i, j+1], lons[i, j+1]
        
        dist = haversine(lat1, lon1, lat2, lon2)
        x_step_distances.append(dist)

# B. 计算垂直 (Y) 方向的步长距离
# 遍历一列中的所有点，计算相邻点间的距离
for j in test_cols:
    for i in test_rows:
        # 选取当前点 (i, j) 和它下面的点 (i+1, j)
        lat1, lon1 = lats[i, j], lons[i, j]
        lat2, lon2 = lats[i+1, j], lons[i+1, j]
        
        dist = haversine(lat1, lon1, lat2, lon2)
        y_step_distances.append(dist)

# 将列表转换为 NumPy 数组以便计算
x_distances = np.array(x_step_distances)
y_distances = np.array(y_step_distances)

# -----------------------------------------------------
# 4. 统计分析和输出
# -----------------------------------------------------

# 统计平均值
mean_x_dist = np.mean(x_distances) if len(x_distances) > 0 else 0
std_x_dist = np.std(x_distances) if len(x_distances) > 0 else 0
mean_y_dist = np.mean(y_distances) if len(y_distances) > 0 else 0
std_y_dist = np.std(y_distances) if len(y_distances) > 0 else 0


print("\n--- 网格步长换算因子摘要 ---")
print(f"X (水平) 方向：1 Index Unit ≈ {mean_x_dist:.3f} ± {std_x_dist:.3f} km")
print(f"Y (垂直) 方向：1 Index Unit ≈ {mean_y_dist:.3f} ± {std_y_dist:.3f} km")
print("----------------------------")

# 检查网格是否为均匀网格
if np.allclose(std_x_dist, 0, atol=0.01) and np.allclose(std_y_dist, 0, atol=0.01):
    print("网格类型：网格步长在整个区域内基本均匀 (Regular Grid)。")
elif mean_x_dist/mean_y_dist > 1.1 or mean_y_dist/mean_x_dist > 1.1:
    print("网格类型：网格步长在 X 和 Y 方向可能存在差异 (Anisotropic Grid)。")
else:
    print("网格类型：网格步长在区域内存在一定变化 (Curvilinear/Non-Uniform Grid)。")


# -----------------------------------------------------
# 5. 可视化：步长分布（自适应直方图）
# -----------------------------------------------------

plt.figure(figsize=(14, 6))

if len(x_distances) > 0:
    # X 方向直方图
    plt.subplot(1, 2, 1)
    # 使用 NumPy 的 Sturges 或 Freedman-Diaconis 规则自动确定 bins
    plt.hist(x_distances, bins='auto', edgecolor='black', alpha=0.7, color='skyblue')
    plt.axvline(mean_x_dist, color='red', linestyle='--', label=f'Mean: {mean_x_dist:.3f} km')
    plt.title('Distribution of X (Horizontal) Grid Step Distance')
    plt.xlabel('Distance (km)')
    plt.ylabel('Frequency of Grid Steps')
    plt.legend()
    plt.grid(axis='y', alpha=0.5)

if len(y_distances) > 0:
    # Y 方向直方图
    plt.subplot(1, 2, 2)
    plt.hist(y_distances, bins='auto', edgecolor='black', alpha=0.7, color='lightcoral')
    plt.axvline(mean_y_dist, color='red', linestyle='--', label=f'Mean: {mean_y_dist:.3f} km')
    plt.title('Distribution of Y (Vertical) Grid Step Distance')
    plt.xlabel('Distance (km)')
    plt.ylabel('Frequency of Grid Steps')
    plt.legend()
    plt.grid(axis='y', alpha=0.5)

plt.tight_layout()
plot_filename = os.path.join(indir_results, 'Grid_Step_Distance_Distribution.png')
plt.savefig(plot_filename)
plt.show()
print(f"步长分布图已保存到: {plot_filename}")

# -----------------------------------------------------
# 6. 最终换算公式提醒
# -----------------------------------------------------

print("\n--- 换算提醒 ---")
print("将 'calculate_and_plot_scales.py' 中的索引结果转换为公里：")
print(f"X方向平均相关尺度 (km) = X_scale_index * {mean_x_dist:.3f}")
print(f"Y方向平均相关尺度 (km) = Y_scale_index * {mean_y_dist:.3f}")