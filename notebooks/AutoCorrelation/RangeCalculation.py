# This program aims to calculate the AutoCorrelation of our 2D wind speed data at one specific time step.
# This program is generated by Junqi Qiu on 2025-10-15

import matplotlib.pyplot as plt
import netCDF4 as nc
import numpy as np
from IPython.display import display, Math, Latex
# We will need to transfer t(seconds since 1970-01-01 00:00:00) to a real date)
import datetime


# 1. Read and Prepare the Data

indir='/home/jqiu/Programing/Wind/'
indir_results='/home/jqiu/Programing/AutoCorrelation/'
fnames=['hrdps_y2025m10d01.nc','hrdps_y2025m10d02.nc','hrdps_y2025m10d03.nc','hrdps_y2025m10d04.nc',
'hrdps_y2025m10d05.nc', 'hrdps_y2025m10d06.nc','hrdps_y2025m10d07.nc', 'hrdps_y2025m10d08.nc',
'hrdps_y2025m10d09.nc','hrdps_y2025m10d10.nc']

day_index=0 # Choose the first day for analysis
t_index=0 # Choose the first time step 
ds=nc.Dataset(indir+fnames[day_index])

t=ds.variables['time_counter']
u_wind_dataarray = ds.variables['u_wind']
v_wind_dataarray = ds.variables['v_wind']
lats=ds.variables['nav_lat']
lons=ds.variables['nav_lon']

lons_data = lons[:]  # 读取所有的经度数据
lats_data = lats[:]  # 读取所有的纬度数据

u_wind=u_wind_dataarray[t_index,:,:]
v_wind=v_wind_dataarray[t_index,:,:]
real_time=datetime.datetime(1970,1,1)+datetime.timedelta(seconds=int(t[t_index]))

# 2. 计算风速标量场 S
wind_speed = np.sqrt(u_wind**2 + v_wind**2)

# --- 3. 计算二维自相关函数 (2D Auto-Correlation) ---

# 3.1. 预处理：移除均值
# 空间自相关通常要求数据是平稳的，这里先移除均值。
wind_speed_prime = wind_speed - np.mean(wind_speed)

# 3.2. 使用 FFT 计算自相关
# 根据维纳-辛钦定理：自相关函数的傅里叶变换是功率谱密度。
# 步骤：
# 1. 计算 FFT
# 2. 计算功率谱密度 (Power Spectral Density, PSD) $PSD = |FFT|^2$
# 3. 计算 PSD 的逆 FFT (IFFT) 得到自相关函数

# 1. 计算 FFT
fft_data = np.fft.fft2(wind_speed_prime)

# 2. 计算功率谱密度
psd = np.abs(fft_data)**2

# 3. 计算自相关函数 (IFFT of PSD)
autocorr_raw = np.fft.ifft2(psd).real  # 取实部，虚部应接近于零

# 4. 调整自相关函数：将零滞后点移动到中心
# FFT 计算出的自相关是周期性的，并且零滞后点在左上角 (0, 0)。
# 使用 fft.fftshift 将零滞后点移到中心，便于分析和绘图。
autocorr_shifted = np.fft.fftshift(autocorr_raw)

# 5. 标准化自相关函数
# 自相关函数在零滞后点的值等于方差，标准化后零滞后点的值为 1。
# $R(\Delta x, \Delta y) = \frac{C(\Delta x, \Delta y)}{C(0, 0)}$
autocorr_normalized = autocorr_shifted / autocorr_shifted.max()


# --- 4. 可视化结果 ---

# 获取自相关场的维度
rows, cols = autocorr_normalized.shape
center_row, center_col = rows // 2, cols // 2

# 创建滞后距离的坐标
# 假设数据是均匀网格，这里使用像素点距离作为滞后距离单位
row_lags = np.arange(-center_row, rows - center_row)
col_lags = np.arange(-center_col, cols - center_col)

# 绘图
plt.figure(figsize=(10, 8))
plt.contourf(col_lags, row_lags, autocorr_normalized, levels=50, cmap='RdBu_r')
plt.colorbar(label='Normalized AutoCorrelation')
plt.title(f'2D Normalized AutoCorrelation of Wind Speed at {real_time.strftime("%Y-%m-%d %H:%M:%S")}')
plt.xlabel('Lag in Column Index')
plt.ylabel('Lag in Row Index')
plt.axvline(0, color='k', linestyle='--', linewidth=0.5)
plt.axhline(0, color='k', linestyle='--', linewidth=0.5)
plt.savefig(indir_results + f'autocorr_2d_{real_time.strftime("%Y%m%d%H%M")}.png')
plt.show()

# --- 5. 额外的分析：提取中心一维自相关曲线 ---
# 通常还会提取沿某一方向（如x轴或y轴）的自相关曲线来分析相关尺度。

# 获取自相关场的维度
rows, cols = autocorr_normalized.shape
center_row, center_col = rows // 2, cols // 2

# 沿水平 (x) 方向的自相关（中心行）
autocorr_x = autocorr_normalized[center_row, :]
col_lags = np.arange(-center_col, cols - center_col)

# 沿垂直 (y) 方向的自相关（中心列）
autocorr_y = autocorr_normalized[:, center_col]
row_lags = np.arange(-center_row, rows - center_row)

# 定义一个寻找特定阈值交点的函数
def find_threshold_crossing(lags, autocorr, threshold):
    """找到自相关函数从 1.0 衰减到指定阈值（threshold）的位置。"""
    
    # 只需要考虑正向滞后，因为函数是对称的
    lags_pos = lags[center_col:]
    autocorr_pos = autocorr[center_col:]
    
    # 查找小于阈值的位置
    cross_indices = np.where(autocorr_pos < threshold)[0]
    
    if len(cross_indices) > 0:
        # 第一次低于阈值的位置
        idx_low = cross_indices[0]
        
        # 确保这不是中心点本身 (idx_low > 0)
        if idx_low == 0:
             # 如果从中心点就开始低于阈值，则跳过
            return None, None 
            
        # 在 idx_low-1 和 idx_low 之间进行线性插值
        idx_high = idx_low - 1
        
        x1, x2 = lags_pos[idx_high], lags_pos[idx_low]
        y1, y2 = autocorr_pos[idx_high], autocorr_pos[idx_low]
        
        # 确保 y1 > threshold 且 y2 < threshold
        if y1 < threshold or y2 > threshold:
             # 确保插值区间跨越了阈值
             return None, None
        
        # 线性插值找到精确的交点 x_cross
        lag_cross = x1 + (threshold - y1) * (x2 - x1) / (y2 - y1)
        return lag_cross, threshold
    return None, None

# 寻找 0.5 衰减点
R_target = 0.5
lag_x_half, R_x_half = find_threshold_crossing(col_lags, autocorr_x, R_target)
lag_y_half, R_y_half = find_threshold_crossing(row_lags, autocorr_y, R_target)

# 寻找零交点（使用原有的 find_zero_crossings 或修改后的 find_threshold_crossing(..., 0.0)）
# 为了简洁，我们继续使用 find_threshold_crossing(..., 0.0) 寻找第一次穿过零点的位置
lag_x_zero, R_x_zero = find_threshold_crossing(col_lags, autocorr_x, 0.0)
lag_y_zero, R_y_zero = find_threshold_crossing(row_lags, autocorr_y, 0.0)


plt.figure(figsize=(12, 5))

# --- 绘制水平 (X) 方向自相关 ---
plt.subplot(1, 2, 1)
plt.plot(col_lags, autocorr_x, label='AutoCorrelation Profile')
plt.title('Horizontal AutoCorrelation (X-Lag)')
plt.xlabel('Lag in Column Index')
plt.ylabel('Normalized AutoCorrelation')
plt.grid(True)

plt.axhline(0, color='k', linestyle='-', linewidth=2, label='Zero Line') 

# 标注 x=0, y=1.00 处的值 (红色)
# plt.plot(0, 1, 'o', color='red', markersize=5)
# plt.text(0, 1.05, f' (0, 1.00)', ha='center', color='red')

# 标注 0.5 衰减点 (红色)
if lag_x_half is not None:
    plt.axvline(lag_x_half, color='red', linestyle=':', linewidth=1)
    plt.plot(lag_x_half, R_x_half, 's', color='red', markersize=5) # 用方形标记
    plt.text(lag_x_half, R_x_half + 0.05, f' ({lag_x_half:.2f}, 0.50)', ha='center', color='red', rotation=-80)
    # 标注负的 0.5 衰减点
    plt.axvline(-lag_x_half, color='red', linestyle=':', linewidth=1)
    plt.plot(-lag_x_half, R_x_half, 's', color='red', markersize=5)

# 标注零交点 (蓝色)
if lag_x_zero is not None:
    plt.axvline(lag_x_zero, color='blue', linestyle='--', linewidth=1)
    plt.plot(lag_x_zero, R_x_zero, 'o', color='blue', markersize=5)
    plt.text(lag_x_zero, R_x_zero + 0.05, f' ({lag_x_zero:.2f}, 0.00)', ha='center', color='blue', rotation=-60)
    # 标注负的零交点
    plt.axvline(-lag_x_zero, color='blue', linestyle='--', linewidth=1)
    plt.plot(-lag_x_zero, R_x_zero, 'o', color='blue', markersize=5)


# --- 绘制垂直 (Y) 方向自相关 ---
plt.subplot(1, 2, 2)
plt.plot(row_lags, autocorr_y, label='AutoCorrelation Profile')
plt.title('Vertical AutoCorrelation (Y-Lag)')
plt.xlabel('Lag in Row Index')
plt.ylabel('Normalized AutoCorrelation')
plt.grid(True)

plt.axhline(0, color='k', linestyle='-', linewidth=2, label='Zero Line') 

# 标注 x=0, y=1.00 处的值 (红色)
# plt.plot(0, 1, 'o', color='red', markersize=5)
# plt.text(0, 1.05, f' (0, 1.00)', ha='center', color='red')

# 标注 0.5 衰减点 (红色)
if lag_y_half is not None:
    plt.axvline(lag_y_half, color='red', linestyle=':', linewidth=1)
    plt.plot(lag_y_half, R_y_half, 's', color='red', markersize=5)
    plt.text(lag_y_half, R_y_half + 0.05, f' ({lag_y_half:.2f}, 0.50)', ha='center', color='red', rotation=-70)
    # 标注负的 0.5 衰减点
    plt.axvline(-lag_y_half, color='red', linestyle=':', linewidth=1)
    plt.plot(-lag_y_half, R_y_half, 's', color='red', markersize=5)

# 标注零交点 (蓝色)
if lag_y_zero is not None:
    plt.axvline(lag_y_zero, color='blue', linestyle='--', linewidth=1)
    plt.plot(lag_y_zero, R_y_zero, 'o', color='blue', markersize=5)
    plt.text(lag_y_zero, R_y_zero + 0.05, f' ({lag_y_zero:.2f}, 0.00)', ha='center', color='blue', rotation=-60)
    # 标注负的零交点
    plt.axvline(-lag_y_zero, color='blue', linestyle='--', linewidth=1)
    plt.plot(-lag_y_zero, R_y_zero, 'o', color='blue', markersize=5)

plt.tight_layout()
plt.savefig(indir_results + f'autocorr_1d_profiles_{real_time.strftime("%Y%m%d%H%M")}.png')